.. _intro:

1장. STON 소개
******************

STON은 인터넷 서비스를 쉽게 확장하기(Easy Scale Out) 위해 개발된 Edge서버이다. 
이전에는 개발과 운영을 따로 규정지었지만 바야흐로 `DevOps <http://en.wikipedia.org/wiki/DevOps>`_ 의 시대이다.
운영없이는 서비스 또한 없다.
하지만 그 동안 운영의 주체인 관리자들의 편안한 주말을 보장해주는 솔루션이 없었다.

STON은 상용솔루션이다.
"상용"의 가장 큰 의미는 장애대처와 재발방지이다.
분명 관리자/개발자들이 책임져야하는 Open Source와는 그 궤를 달리한다.
STON의 개발목표는 국내외 수 많은 서비스를 통해 검증된 신뢰를 모든 고객에게 전파하는 것이다.



.. toctree::
   :maxdepth: 2


서비스 리스크
====================================

서비스는 시작되는 순간부터 수많은 위험에 노출된다. 
장애는 언제든 발생할 수 있다. 
점점 많은 사용자와 콘텐츠를 확보할수록 위험과 비용은 예측할 수 없을 만큼 커진다. 
특히나 요즘엔 서비스가 전파되는 시간이 점차 짧아지고 있다. 
이제 누구도 섣불리 미래를 예측할 수 없다.

우리 앞에 놓인 Risk가 무엇인지 정확하게 알아보자.



물리적 한계
---------------------

서비스를 구성하는 S/W는 매우 유연하며 탄력적인 자원이다. 
하지만 H/W 한계를 넘어서는 동작할 수 없다. 
종종 개발자들이 개발 과정에서 S/W에 집중하다 보면 H/W 한계나 운영성을 등한시하는 경우를 본다.
어쩌면 막연히 "좋은 H/W를 구매하면 돼" 또는 "메모리 더 꽂으면 돼" 라는 안일한 생각을 할지도 모른다.

S/W의 범위와 영향력이 넓어지고 서비스 중심으로 시장이 흘러가는 요즘은 더욱 그렇다. 
하지만 서비스는 필연적으로 H/W의 한계에 다다른다.

.. figure:: img/intro_car.png
   :align: center
      
   결국 서버를 사야돼
   
아무리 거대한 서비스라도 결국 물리적인 서버의 집합 위에서 동작한다. 
서버를 구성하는 모든 자원은 한계성을 가지며 서비스는 이런 한계성을 넘어설 수 있도록 설계되어야 한다.

운영할 수 없는 서비스는 마치 달리지 못하는 자동차와 같다. 
서비스 개발 단계에서 Scale-Up 할 자원과 Scale-Out 할 자원을 명확히 구분해야 한다. 
Scale-Out할 수 없다면 절벽을 향해 떠내려가는 땟목과 마찬가지다.



관리자는 어디에?
---------------------

단순계산으로 서버 10대 관리비용이 10이라면 100대의 비용은 100이라고 생각하기 쉽다. 
하지만 대부분 관리자는 최소 1000이상이며 대부분의 경우 추정할 수 없다고 말한다. 
관리기술이 모자란 서비스 관리는 서비스를 헤어나올 수 없는 늪에 빠트린다. 
서버가 "저 아파요~" 라고 말하면 얼마나 좋을까. 
하지만 H/W는 문제가 발생하기 전까지 문제삼지 않는다.
관리자에겐 끊임없는 점검만이 있을 뿐이다. 

신규 서버는 배치하고, 고장 나거나 수명이 다한 서버는 교체해야 한다. 
관리자에 의한 최적화가 이루어지지 않는다면 H/W 가동률은 떨어진다. 
성능을 100% 내지 못한다니 아마도 추가 H/W를 더 구매해야 할지도 모르겠다.

.. figure:: img/intro_money.png
   :align: center
      
   사람은 돈이다
   
기업은 서비스를 더 안정적으로 관리할 수 있는 인력이 필요하다. 
하지만 언제까지 사람으로 메꿔야 할지... 끝이 보이지 않는다.
그나마 실력이 뛰어난 관리자를 구할 수 있다면 여러분은 행운아다.



예고된 장애
---------------------

사람은 언제나 실수하는 동물이니 인재는 제외하자. 
인재의 확률을 줄이고 싶다면 좋은 관리자를 찾아야 한다. 
실수가 없을 것 같은 기계는 어떨까? 확실한 건 기계는 고장난다는 사실뿐이다. 
전력수급 장비에 문제가 생기는 일도 분명히 존재한다. 
이런 경우 UPS(Uninterruptible Power Supply)등의 장애대비용 장비가 있지만, 
절대적인 장애확률을 낮추기 위해 다른 공간(Server Farm)을 선택하는 경우도 흔하다. 
장애 상황까지 고려해 2중화/3중화 한다면 이제 서버는 곱하기로 늘어난다.

.. figure:: img/intro_dance.png
   :align: center
      
   복제는 축제!
   
서버 속을 들여다보자. 
벼락이라도 맞지 않는 이상 서버의 모든 부품이 동시에 망가지는 경우는 거의 없다. 
서버를 구성하는 부품(CPU, Memory, NIC, Disk) 중 가장 빨리 그리고 빈번히 고장나는 것은 디스크이다.
오죽하면 디스크 이야기에는 "수명"이라는 단어가 빠지지 않다. 

디스크 장애의 가장 치명적인 점은 소중한 콘텐츠가 모두 사라진다는 점이다.
RAID를 사용할 수도 있지만 역시 성능과 비용 사이에서 균형점을 찾아야 한다. 
디스크를 교체했다해도 텅 빈 디스크로는 아무것도 할 수 없다. 
어딘가에서 복사해와야 한다. 
실제 서비스에는 복사할 때 며칠씩 소요되는 경우도 허다하다. 
물론 이 순간에도 콘텐츠는 업로드와 삭제를 반복하고 있다. 
단언컨대 이런 일이 2번 반복되면 그 누구도 모든 서버의 디스크에 같은 데이터가 
존재한다고 말할 수 없다. 
이런 서비스를 고객이 신뢰할 수 있을까?



Storage & Single Point of Pain
---------------------

디스크 동기화는 정말 어려운 문제다. 
NAS(Network Attached Storage)나 SAN(Storage Area Network) 또는 
DAS(Direct Attached Storage)가 흔한 솔루션이다. 
서비스 규모에 맞는 Storage를 구성해 동기화 문제를 해결해도 또 다른 문제가 있다. 

이 "단 하나의" Storage가 죽으면 어떻게 될까? 
눈을 감고 10초만 상상해보자.
달걀을 절대 한 바구니에 담지 말자. 데이터는 이중화도 부족하다.

.. figure:: img/intro_egg.png
   :align: center
      
   Storage가 바구니 가격이었다면...
   
초기 Storage 도입만으로도 동기화 문제가 해결되고 서비스도 안정적일 수 있다. 
하지만 서비스 규모가 커지면 Storage로 부하가 집중되기 시작한다. 
초당 10개의 요청을 처리하던 Storage가 100개를 처리하는 순간 아무도 응답을 받지 못하는 상황이 발생할 것이다. 
그리고 처리되지 못한 요청은 계속 쌓이게 될 것이다. 
클릭하고 라면 끓여먹고 와야할지도 모른다.

.. figure:: img/intro_diskworst.png
   :align: center
      
   이런 그래프는 주식에만 있는 것이 아니다
   
Storage는 대부분 고가이다. 
좋은 걸 사자면 한도 끝도 없다. 
따라서 `만수르 <https://mirror.enha.kr/wiki/%EC%85%B0%EC%9D%B4%ED%81%AC%20%EB%A7%8C%EC%88%98%EB%A5%B4%20%EB%B9%88%20%EC%9E%90%EC%98%88%EB%93%9C%20%EC%95%8C%20%EB%82%98%EC%96%80>`_ 가 아니라면 누구나 경제적인 선택을 할 수밖에 없다. 
분명 Storage는 한계에 다다른다. 

이런 경우 대부분 새로 사야 한다. 
확장성이 뛰어나면서도 안정적이고 속도도 빠른 Storage를 살 수도 있지만, 
가격을 보면 그런 마음이 눈 녹듯 사라질 것이다.


Burst와 연쇄부도
---------------------

Burst는 예측할 수 없이 온다. 
가령 유명인이 TV에 나와서 여러분의 서비스를 언급하는 순간 평소 사용자의 10배가 넘는 사용자를 만나게 될 것이다. 

평소 1만 명을 10대의 서버로 처리하는 서비스가 10만 명을 맞이하는 상황을 생각해보자.
이제 서버마다 10배를 처리해야 한다. 
이때 정신력이 약한 1번 서버가 부하를 버티지 못하고 전사했다. 
이제 나머지 9대가 부하를 나누어서 처리해야 한다. 
또 한대가 버티지 못하고 전사했다. 
남은 대수에 상관없이 결국, 모든 서버가 연쇄적으로 무너지게 될 것이다.

.. figure:: img/intro_domino.png
   :align: center
      
   다음은 너다
   
Burst는 눈덩이와 같다. 
버티지 못하면 점점 커져서 공격한다. 

그렇다고 서버를 100대로 늘려야 할까? 
그러면 평소 현재 처리량의 10분의 1만을 처리하며 펑펑 놀게 될 것이다. 
아 도대체 어쩌라고...


진료는 의사에게, 약은 약사에게
---------------------

**"개발은 개발자에게, 운영은 관리자에게"** 
산업이 성장하면서 전문화, 고도화는 당연한 수순이다. 
그래서 개발자는 개발에 집중하고 관리자는 운영에 집중한다. 
하지만 "서비스는 개발자가 낳아서 관리자가 키운다." 라는 말이 무색하게 
개발팀과 운영팀은 대부분 사이가 안좋다. 
출산의 고통은 크지만, 관리자들에겐 끝이 없는 육아가 시작된다. 
문제는 도대체가 이 개~~~~~~~~~발자 분들이 관리자들의 마음을 몰라주며 
독불장군처럼 행동하는 경우가 많다는 것이다.

.. figure:: img/intro_parentfight.png
   :align: center
      
   그만 좀 싸우세요 ㅜ.ㅜ
   
DevOps는 그냥 말뿐인걸까?



Open Source는 누가 책임지나?
----------------------------

여기 길거리에 먹기 좋고 보기 좋은 음식이 있다. 
게다가 공짜다. 
하지만 세균이 가득한 음식일 수도 있다. 
주변 사람들에게 물어보니 배탈이 난 사람도 있고 아닌 사람도 있다고 한다. 
배탈이 안나면 정말 좋겠다. 
나는 괜찮을 수 있지만 다른 사람들도 그럴지 보장할 수 없다. 

Open Source도 비슷하다. 
가져다 쓰는 것은 마음대로지만 아무도 책임지지 않는다. 
빠르게 패치된다고? 그런 기약없는 말 말고 당장 화장실로 휴지를 가져다 줄 사람이 필요하단 말이다!
 
.. figure:: img/intro_idontknow.png
   :align: center
      
   아 몰라~ 몰라~

비극은 개발자가 Open Source웹 사이트를 클릭하면서 시작된다.
그들의 주관심사는 기능이지 운영이나 안정성이 아니다. 
그렇게 만들어진 서비스가 1주일마다 어떠한 로그도 없이 죽어버리면 어떨지 상상해보자. 
책임을 Open Source를 선택한 개발자에게 물어봤자 돌아오는 대답은 뻔하다. 
"포럼을 뒤져보았지만, 우리 같은 경우를 찾을 수 없었다." 
이제 뭘 해야 할까?


검증되었다
----------------------------

A사가 서비스를 시작하면서 무수히 많은 시행착오를 겪는다. 
B사도 같은 시행착오를 겪는다. 
A, B사의 사람들이 C사에 가지 않는 이상 C사 역시 마찬가지다. 
이 얼마나 소모적인 반복인가. 
제품이란 이런 낭비적인 기회비용을 줄여줌으로써 가치를 가진다. 
이른바 기회비용을 줄여주는 것이다. 

A사가 사용하는 제품이 큰 장애상황을 견뎠다면 C사 역시 그 제품을 선뜻 선택할 수 있다. 
특히나 엔터프라이즈 서비스에서 "검증되었다." 란 말은 "사귀어 줄께" 와 동급이다.
나랑 안사귀면 아무 의미 없다.

.. figure:: img/intro_guarantee.png
   :align: center
      
   책임지지 못할 짓은 하지 말자
   
여러 서비스를 두루 거치면서 "검증된" 제품이야말로 가장 든든한 동지다. 
먼 길을 떠나는데 "검증되지 않은" 사람들과 같이 가는 것은 언젠가 화를 부른다.


결론
----------------------------

이상의 내용을 쩌는 라임으로 요약하자. :: 

    서버를 사면 돈이 들고, 
    이중화를 하면 곱하기로 돈이 들고, 
    관리자를 교육하려면 돈이 들고, 
    검증되고 고성능 제품을 사려면 돈이 많이 들고
    
    돈, 돈, 돈...
    show me the money
    
그렇다. 결국 돈이다. 
모두가 싸고 좋은 구성을 꿈꾸지만, Risk 앞에서 합리적인 선택을 해야 한다.



정의와 역할
==============================

.. note::
   
   Reverse-Proxy라는 개념에 익숙치 않다면 제이펍에서 출간된  
   `24시간 365일 서버/인프라를 지탱하는 기술 <http://www.yes24.com/24/Goods/3377489>`_ 의 2장을 읽어보자.
   
Cache는 컴퓨터의 탄생부터 존재해온 개념이다.
CPU내부에도 여러 단계의 Cache가 존재하고 OS도 디스크에 저장된 데이터를 메모리에 Caching한다.
단언컨데 Cache는 가장 효율적이며 검증된 방법이다.

인터넷의 도래와 함께 네트워크 상에서 동작하는 Cache가 필요해졌다.
이를 구현한 것을 Topology에 따라 Proxy, Reverse-Proxy로 구분한다.
대표적인 Open Source로 `Squid <http://www.squid-cache.org/>`_ 나 `ATS(Apache Traffic Server) <http://trafficserver.apache.org/>`_ 가 존재한다.
인터넷 환경의 발달과 함께 Proxy는 거의 유명무실해졌다.
주로 Reverse-Proxy를 사용하며 흔히 Web Cache라고 부른다.

.. figure:: img/into_reverseproxy.png
   :align: center
      
   Reverse-Proxy의 개념

`CDN <http://en.wikipedia.org/wiki/Content_delivery_network>`_ 의 보편화와 
모바일시대의 도래는 새로운 운영환경을 요구했다.
특히나 빠른 서비스형태의 변화와 다양한 클라이언트 환경을 기업이 저마다 Follow-up하는 것은 매우 부담스럽다.


Edge서버의 가장 큰 특징은 다음과 같다.

-  원본을 대신하여 서비스를 대중에게 전달한다.
-  대중으로부터 서비스를 보호한다.
-  서비스가 핵심적인 역할만 수행할 수 있도록 보조한다.

가수에게 마이크가 있다면 서비스엔 이제 Edge가 필요하다.
**효과적으로 전달** 하려면 서비스 설계와 확장에 Edge의 개념이 필수다.
적용사례를 중심으로 Edge서버의 적용범위에 대해 알아보자.


Game
----------------------------

전통적으로 게임 서비스는 엄청나게 많은 대역폭을 필요로 한다. 
"대작" 게임부터 간단한 캐주얼 게임까지 범주도 매우 다양하다. 
특히 스마트폰 게임의 폭발적 성장과 전파속도는 서비스 형태를 더욱 다양하게 만들었다.

.. figure:: img/icons_game.png
   :align: center

- **높은 대역폭 출력**
  
  단일 서버로 높은 대역폭을 얻는 전통적인 방법은 1Gbps NIC를 본딩(Bonding)하는 것이다. 
  이를 통해 4Gbps 대역폭까지 얻을 수 있다. 
  최근 10Gbps NIC도 시장에 많이 보급되는 추세이다.

  ``STON`` 4Gbps NIC Bonding과 10Gbps NIC에서도 최대 대역폭을 보장한다.
  
- **사용자 대역폭 보장**

  모든 사용자는 게임을 빨리 다운로드 받고 싶어한다. 
  광랜 사용자는 100Mbps의 속도가 얻어지지 않는다면 항의 전화를 걸 것이다. 
  모두들 빨리 게임을 시작하고 싶어한다. 
  서버는 물리적으로 대역폭이 꽉 차지 않는 이상 사용자마다의 최대 속도를 균일하게 보장해야 한다. 
  
  ``STON`` 모든 사용자에게 최대 속도로 전송하는 것을 보장한다.
  
- **대용량 파일 처리**

  설치파일이 4GB정도 하는 게임은 이제 대형게임으로도 분류되지도 않는다. 
  수십 GB는 되어야 "대작"이라는 단어를 달 수 있는 세상이다. 
  파일이 너무 크면 서버 메모리에 모두 Caching 할 수 없다. 
  최악의 상황은 파일의 크기가 너무 커서 사용자마다 다운로드 받는 위치가 제각각인 상황이다.
  
  ``STON`` Caching 파일크기 제한이 없다. 
  Memory와 Disk의 적절한 Swap을 통해 언제나 고성능을 보장한다.
    
- **Range 요청처리**

  전송 파일이 대형화되는 추세에 따라 Grid Delivery기법의 P2P솔루션도 많이 사용되고 있다. 
  이런 솔루션의 특징은 파일을 잘게 조각 내어 주고 받기 때문에 서버에 엄청나게 많은 
  HTTP Range요청을 보낸다. 
  10GB파일을 만 명의 클라이언트가 서로 다른 Range로 요청하는 상황도 가능하다. 
  어느 부분을 요청하더라도 서비스는 즉시 가능해야한다. 
  하지만 원본서버에서는 반드시 원래 파일의 크기만큼만 데이터가 전송되어야 한다.
  
  ``STON`` Range요청에 최적화된 파일 시스템이 탑재되었다. 
  또한 멀티 다운로드를 통해 빠른 응답성을 보장한다.
  원본서버로부터 1Bytes라도 불필요한 다운로드는 하지않는다.


쇼핑몰
----------------------------

쇼핑몰은 사이트 접근이 고객의 매출과 직결된다. 
이제 전통적인 PC환경 뿐만 아니라 모바일쇼핑이 당연해졌다. 
쇼핑환경이 다양해 지는 것 뿐만 아니라 무한히 늘어나는 
파일을 관리하지 못한다면 서비스는 곤경에 처한다.

.. figure:: img/icons_shopping.png
   :align: center

- **무한대의 작은 파일**
  "억! 단위를 넘어서는~", "셀 수 없이 많은~", "언제나 늘어나기만 하는~" 파일을 
  저장하기 위해서는 고가의 Storage가 필요하다. 
  하지만 경제성이 중요한 Edge서버에서는 그럴 수 없다. 
  크기가 1KB인 파일이 10억 개 존재하는 서비스도 있을 수 있다. 
  결론적으로 모든 파일을 Caching할 수 없다. 
  원본서버의 부하를 최소화하면서도 접근 빈도가 높은 파일을 항상 유지하는 방법이 필요하다.

  ``STON`` 메모리와 Disk 자원의 최대용량만큼 Caching한다. 
  모든 파일의 접근 빈도는 실시간으로 관리되며 LRU(Least Recently Used) 에 의해 
  오래된 파일 순으로 삭제된다.
  
- **많은 사용자**

  쇼핑몰은 많은 사용자를 동시에 처리할 수 있어야 한다. 
  급작스러운 이벤트에 의해 사용자 접속이 폭발적으로 증가(=Burst)하기도 한다. 
  Burst 시 서버는 스스로를 보호해야 하며 Burst 후에도 안정성을 유지해야 한다.
  
  ``STON`` CPU 조정성(Scalability. 자원의 증설에 따라 솔루션의 성능이 높아지는 것)을 보장한다. 
  탄력적인 HTTP Keep-Alive 처리와 소켓관리를 통해 Burst시에도 안정성을 보장한다.
  
- **반응성**

  쾌적한 쇼핑환경이란 페이지가 빠르게 로딩되는 것을 의미한다. 
  사용자는 기다리지 않는다. 
  3초 안에 로딩되지 않으면 다른 사이트로 떠난다. 
  일반적으로 메인 페이지는 100개 내외의 파일로 이루어지며 물리적 환경을 고려하더라도 통상 1초 대에 페이지는 완벽하게 로딩되어야 한다.
  
  ``STON`` 실시간 파일 인덱싱을 통한 즉시 응답을 보장한다. 
  부드러운 파일교체를 통해 원본 종속성 없이 반응성을 극대화할 수 있다. 
  모든 HTTP 응답(First byte 응답, 트랜잭션 완료)에 대해 로그와 통계수치를 제공하여 
  성능저하 여부를 실시간으로 검출할 수 있다.
  
- **페이지 TTL**

  대다수의 사용자의 이동 경로는 메인 페이지 -> 대형 카테고리 페이지 -> 소형 카테고리 -> 상세 페이지 순이다. 
  페이지마다 노출 빈도가 다를 뿐만 아니라 갱신 주기도 달라야 한다. 
  스마트한 페이지 Caching & 갱신 방법이 필요하다.
  
  ``STON`` URL마다 별도의 TTL을 부여할 수 있다. 
  또한 Purge, Expire, ExpireAfter, HardPurge 등 상황에 맞는 다양한 방식의 갱신 방법을 제공한다.
  
  

미디어
----------------------------

미디어 전용 프로토콜은 점차 설 자리를 잃어가고 있다. 
HTTP, MP4의 간단하지만 강력한 조합은 점차 세력을 넓혀가고 있다. 
모바일의 가변적인 연결상태를 고려 한다면 HTTP 기반의 Streaming방식이 전송 표준이 될 것이다.

.. figure:: img/icons_media.png
   :align: center

- **미디어 인식**

  더 이상 파일을 Chunk로 인식해서는 안된다. 
  미디어 파일을 정확히 인식할 수 있어야만 대역폭 절감과 함께 다양한 부가기능을 연동할 수 있다. 
  서버가 파일 해석을 위해서 파일의 모든 부분을 필요로 한다면 사용자는 영상재생을 포기할 것이다.
  
  ``STON`` MP4, MP3, M4A, FLV 포맷을 지원한다. 
  다운로드와 동시에 HTTP Pseudo Streaming을 위해 필요한 영역을 우선적으로 Caching한다.
  
- **미디어 헤더 재배치**

  헤더가 뒤에 있는 파일의 경우 HTTP Pseudo Streaming이 불가능하다. 
  이를 위해서는 전용 플레이어가 필요하지만 이는 사용자에게 짜증을 +10한다.
  
  ``STON`` MP4파일 인코딩 후 헤더가 뒤에 붙는다면 헤더를 앞으로 옮겨주는 작업을 
  추가적으로 수행해야 한다. STON은 자연스럽게 헤더를 앞으로 옮겨 서비스 한다.
  
- **대역폭 조절**

  대부분의 영상을 끝까지 보는 사용자는 드물다. 
  그러므로 재생에 무리가 없도록 필요한 만큼만 대역폭을 사용하는 것이 효율적인 전송방법이다. 
  같은 영상이더라도 360p, 480p, 720p, 1080p처럼 Bitrate를 다양하게 서비스 한다.
  
  ``STON`` Bandwidth-Throttling을 통하여 미디어 파일의 전송 대역폭을 최적화할 수 있다.

- **구간추출**

  미리보기/하이라이트/공유하기 등 파일 전체가 아닌 특정 구간만을 서비스하는 경우도 많다. 
  서비스하는 모든 파일에 대해 구간을 추출하는 것은 시간과 저장공간을 지나치게 낭비한다. 
  심지어 사용자마다 추출 구간이 다른 경우도 있다. 
  또한 Skip기능을 구간 재생으로 구현하는 플레이어도 존재한다.
  
  ``STON`` Trimming기능을 통해 구간을 추출하여 완전한 형태의 미디어 파일로 서비스한다.
  
  
뉴스 / 커뮤니티
----------------------------

아주 높은 충성도의 사용자층을 확보한 사이트는 흥미로운 점이 많다. 
같은 관심사를 가지는 사용자들이 모이기 때문에 교류가 활발하며 페이지에 
머무르는 시간도 매우 길다. 
서비스 패턴이 제각각이라 서비스하기 꽤 까다롭다.

.. figure:: img/icons_news.png
   :align: center

- **304 Not Modified**
  
  사이트 충성도가 매우 높기 때문에 이미 대부분의 파일을 사용자 로컬에 저장하고 있다. 
  때문에 실제로 전송되는 파일보다 "변경확인" 비율이 압도적이다.
  
  ``STON`` 자주 접근되는 파일은 항상 메모리에 상주하도록 보장한다. 
  "변경확인" 작업은 기다림 없이 즉시 처리된다.
  
- **Bypass**

  사용자에 특화된 페이지나 새로운 글, 리플 등 페이지는 항상 Caching할 수 없는 영역을 포함한다. 
  하지만 Domain을 별도로 나누지 않고 단일 도메인을 Reverse-Proxy에 위임하는 경우가 많다.

  ``STON`` 다양한 조건을 기반으로 바이패스 대상을 정교하게 분류한다. 
  또한 Origin Affinity, Private 기능을 이용해 로그인 세션을 유지할 수 있다.
  
- **불안한 원본**

  중, 소형 기업 또는 개인이 운영하는 사이트들은 고가의 장비나 인프라, 인력을 운영하기 어렵다. 
  원본서버 장애 빈도가 상대적으로 높으며 이를 극복하기 위한 경제성은 매우 나쁘다.
  
  ``STON`` 원본서버 과부하 또는 장애를 판단하여 자동으로 배제/복구가 이루어진다. 
  원본서버 장애 시  TTL을 자동으로 연장시켜 원본서버 의존성을 최소화한다.
  
- **이미지 가공**

  같은 이미지를 사용자 환경에 따라 다양하게 보여줄 필요가 있다. 
  검색 결과에서는 Thumbnail 이미지를, 뉴스 사이트에서는 "XX 뉴스" 같은 글씨를 워터마크로 표시해야한다. 
  같은 이미지를 보여지는 형태에 따라 매번 가공하는 것은 저장공간과 시간, 인력의 낭비다.
  
  ``STON`` DIMS기능을 사용하면 원본서버에 단 하나의 이미지 만으로 원하시는 형태를 
  URL 호출만으로 생성할 수 있다.
  
  
파일기반 서버
----------------------------

Edge는 Reverse-Proxy구조에 기반한다. 
Reverse-Proxy의 핵심 개념은 원격서버에 있는 파일을 로컬에 복제/갱신/관리하는 것이다.
이미 검증된 STON을 서비스 서버와 연동할 수 있다면 
Storage중앙 집중화 및 동기화 이슈를 제거할 수 있다. 
뿐만 아니라 개발시간 단축과 서비스 신뢰도 향상의 두마리 토끼를 모두 잡을 수 있다.

.. figure:: img/icons_file.png
   :align: center

- **File I/O 지원**

  전용 프로토콜이 필요하다면 해당 모듈에 종속적인 서버가 되어 버린다. 
  힘들게 연동했다 하더라도 성능이 떨어지면 무용지물이다. 
  모듈과 서버 사이의 중간 단계는 최소화되어야 한다.
  
  ``STON`` 표준 File I/O로 STON이 연동된다. 
  전용서버와 STON사이에는 Linux Kernel(VFS)만이 존재하여 고성능을 보장한다.
  
- **Web Server 연동**
  
  표준 Web 서버(Apache, Lighttpd, NginX)에 특화된 확장모듈이 설치된 경우 
  표준 Reverse-Proxy를 도입하기 힘들 수 있다. 
  DB/WAS와 연동되는 파일 서비스 또는 과금/결제 서비스 같은 경우 쉽게 서비스를 
  확장하기 어렵다.
  
  ``STON`` Apache의 DocumentRoot를 STON으로 지정하면 Apache는 STON을 물리적 디스크로 인식한다. 
  더 설정할 것은 없다.
  
- **Wowza 연동**

  미디어서비스에서는 Wowza가 사실상의 표준이다. 
  하지만 Wowza의 HTTP Caching기능은 사용하기 번거로울 뿐만 아니라 빈약하다. 
  또한 점차 HTTP 이외의 "전용" 프로토콜은 사라지는 추세이다.

  ``STON`` 로컬 디스크로 Mount할 수 있을 뿐만 아니라 MP4헤더 변환, Trimming등 
  모든 기능을 사용할 수 있다.

- **리소스 제약**

  Back-end에 존재하는 파일을 Front-End의 사용자에게 전달하는 서버라면 항상 
  파일 동기화가 문제된다. 
  게임서버, SNS서버 등 전용서버의 개발 이슈는 항상 존재한다. 
  이런 서버의 경우 중단 없이 장기간 운영 되야 하므로 
  메모리, 디스크 사용이 엄격하게 제한되어야 한다.

  ``STON`` 최대 메모리, 디스크 사용량을 제한할 수 있다. 
  또한 디스크로 Mount하여도 다른 모든 기능은 동일하게 동작하여 복합적인 서비스를 
  최소한의 솔루션으로 구성할 수 있다.



특성과 철학
==============================

STON은 관리자를 위해 존재한다.
관리자에 의해 운영되고, 관리자에 의해 검증되고, 관리자에 의해 개선되는 제품이다.
STON개발팀이 이루고 싶은 가치는 고객, 관리자와 함께 더 나은 서비스를 만드는 것이다.

.. figure:: img/intro_triangle.png
   :align: center
      
   우리가 꿈꾸는 아름다운 세상
   
   
No Open Source
----------------------------

"어떤 소스를 기반으로 만들었나요?" 개발초기 고객을 만날 때마다 한번은 꼭 들어야 했던 질문이다.
용역이나 단기간의 매출증대용 제품이었다면 Open Source를 기반으로 개발했을지도 모른다.

.. figure:: img/intro_copycat.png
   :align: center
      
   눈 딱 감고 복사해버릴까?

하지만 그렇게 개발해봤자 베낀 소스의 Copy Cat밖에 못된다.
서두에서 언급한 바와 같이 "~같은 제품"이 아닌 "관리자를 위한~" 솔루션을 만들고 싶었다. 

서비스에서 장애는 필연적이다. 
사람과 마찬가지로 솔루션도 실패를 먹고 자란다. 
하지만 소스가 온전히 내 것이 아니라면 실패를 기반으로 성장할 수 없다.
요구사항으로부터 결과물이 나올 때까지 모든 과정이 개발팀 안에서 소화되지 않는다면 해결됐다고 말할 수 없다. 

개발팀이 가장 견디기 어려운 상황은 "내가 개발하지 않아서 잘 모르는" 상황이다. 
이런 장애는 재발될 것이며 근본적인 원인에 집중하기보다 상황을 모면하기 위한 임시방편용 코드로 도배가 될 것이다. 
가장 정직하지만 가장 근본적인 해결책은 처음부터 끝까지 모두 직접 개발하는 것이다.
왕도는 없다.


Agile
----------------------------

v2의 릴리스까지 공식적인 릴리스만 2년간 70회 이상 있었다. 
보통 1달에 1~2번 정도는 꼭 릴리스를 하려고 노력한다. 
릴리스 주기가 길어질 수록 코드는 안정성과 거리가 멀어진다. 
1년 만에 나온 버전과 1달 만에 나온 버전 중 어느 쪽이 안정성이 
높을지 답은 뻔하다. 
더 많은 것을 담으려 할수록 안정성은 떨어진다. 
당장이라도 릴리스 할 수 있는 소스여야만 고객의 요구사항에 빠르게 대응할 수 있다.

.. figure:: img/intro_agile.png
   :align: center
      
   너무 오래 돌리면 어지럽다.
   
단순히 릴리스 주기를 짧게 가져가는 것이 전부는 아니다. 
모두가 문제에 집중하고 최선의 답을 찾기 위해 더 많은 아이디어를 낼 수 있는 
시간이 바로 고객이 요구사항을 낼 때 다. 
요구사항이 몇 달 뒤에 결과가 나온다면 모두의 열정이 식어버리고 말 것이다. 
쇠가 달궈졌을 때 두드려야 한다.


C/C++
----------------------------

High Performance를 위해 가장 고민 했던 것은 개발 언어를 선택하는 것이었다. 
처음엔 Erlang을 고려했었다. 
안정성과 무중단 서비스가 솔루션의 컨셉과 잘 맞다고 생각했다.

개발자들은 저마다의 이유로 개발 언어를 선택한다. 
하지만 모든 개발언어에는 분명 Trade-Off가 있으며, 
개발의 끝에 가서 언어의 태생적인 문제 때문에 경쟁력을 잃는 경우가 발생하기도 한다. 
관리자는 성능이 50인 솔루션보다 100인 솔루션을 도입해야 한다. 

눈에 보이는 Throughput만을 보고 판단하는 것은 아니다. 
Performance는 관리비용, 전기세, 상면 등등 여러 부대비용의 직접적 원인이 된다. 
성능은 경제성을 결정한다.

.. figure:: img/intro_cpp.png
   :align: center
      
   그렇다고 이런 옷을 입진 않는다.
   
이런 관점에서 개발언어로 C/C++을 선택한 것은 당연한 일이었다. 
언어의 태생적인 이유 때문에 "Performance"가 문제가 되는 상황은 피하고 싶었다. 


그냥 잘 되야 한다.
----------------------------

기업의 S/W, H/W환경은 매우 다양하다. 
솔루션에는 가급적 이유가 없어야 한다. 
그냥 잘 되야 한다. 
많은 조건이나 제약을 동반하는 솔루션은 결국 높은 도입비용을 유발한다. 

모든 Linux에서 동일하게 구동되는 솔루션을 만들고 싶었다. 
그래서 항상 별도의 의존성 패키지가 필요치 않도록 개발한다. 
범용성은 H/W를 증설할 때도 중요한 요소가 된다. 
관리자는 H/W 자원을 업그레이드 할 때 그만큼의 성능향상을 기대한다. 
각 자원의 관점에서 STON의 기반 설계 원칙은 다음과 같다.

- **CPU** 

  Many-Core에 최적화 되어야 한다. 코어개수와 Throughput은 비례한다.
  
- **Memory**
 
  Memory가 많을수록 빠르게 처리할 수 있다. Disk I/O를 절감한다.
  
- **Disk**

  I/O 를 균등 분산한다. 더 많은 데이터를 caching한다.
  
- **NIC**

  4Gbps NIC Bonding 또는 10Gbps NIC의 Bandwidth를 보장한다.
  
  
강력한 모니터링/로그
----------------------------

서비스의 모든 것은 숫자로 설명된다. 
페이지가 몇 초 만에 로딩되는지, 동시접속자는 얼마나 되는지, 가장 처리량이 많은 시간은 
언제인지 등등 숫자가 많을수록 서비스를 입체적으로 볼 수 있다. 
시간도 아주 중요한 요소이다. 
"어제" 얻어진 숫자가 은이라면 "지금" 나오는 숫자는 다이아몬드 이다.

.. figure:: img/intro_plane.png
   :align: center
      
   다 필요할 때가 있다.
   
로그는 금이다. 
로그는 모든 것을 증명한다. 
로그는 분쟁지역에 파견된 UN 평화군 같은 역할을 한다. 
가급적 서비스가 뱉어내는 모든 숫자를 실시간으로 제공하고자 한다.

실시간, 5분 평균, n(1~60)분 평균 뿐만 아니라 JSON, XML, SNMP 등 
다양한 방식으로 관리자에게 숫자를 제공하기 위해 노력한다. 
서비스를 진행하면서 지속적으로 로그를 보강하고 있고 
사금을 모으는 심정으로 로그를 기록한다.



설정은 무조건 쉬워야 한다.
----------------------------

설정은 관리자가 제품을 맨 처음 만져보게 되는 곳으로 무조건 쉬워야 한다. 
옛말에 "환경설정이 반이다"라는 말도 있잖은가. 
Linux도 예전에 비해 많이 쉬워졌다고는 하지만 여전히 
Open Source를 구동시키는 일은 간단하지 않다. 

구동시키는데 성공했다고 하더라도 설정과정에서 뜻대로 동작하지 않는 과정을 거치며 
관리자는 좌절한다. 
좌절보다는 분노가 더 적합한 단어 같지만... 어쨌든. 
종종 분노를 넘어선 고객이 만렙 달성 후 "저주" 기술을 마스터하는 것을 목격하기도 한다. 
특히 Web Cache처럼 다양한 서비스 형태를 모두 극복해야 하는 솔루션의 경우 
한도 끝도 없이 복잡해지는 경우가 많다. 

.. figure:: img/intro_unclebob.png
   :align: center
      
   선생님... 하나도 안 쉬워요
   
기술적인 이유 때문에 설정방법이 복잡해지는 것은 최대한 피하고자 한다.
쓸데없이 설정파일이 길어지는 것도 피하고자 한다. 
고객이 어려워할 수 있는 요소들은 최대한 배제한다.


강력한 기술지원
----------------------------

모든 서비스 장애 시 개발팀이 직접 지원한다. 
필요할 경우 장애 복구용 버전을 즉시 릴리스 하기도 한다. 
고객이 장애를 탐지하지 못하거나 장애 상황에 올바르게 대처하지 못한 것은 
다 STON개발팀의 부족 때문이다. 
우리는 "나중에" 라는 단어를 모른다. 
고객의 속이 까맣게 타 들어가기 전에 모든 상황을 종료하기 위해 노력한다. 

.. figure:: img/intro_support.png
   :align: center
 
   실시간 코딩

개발자는 고객을 직접 만나야 한다.
이것이 고객과 소통하는 가장 직접적이면서도 효과적인 방법이다.



고객과 요구사항
==============================

우리는 고객이 필요하다면 대부분 개발한다.
정식으로 지원되지 않는 기능이라면 준비가 되기 전까지 
Customizing(특정 고객전용 코드를 짜 넣는 일)을 해서라도 지원하려 한다. 
소스의 안정성이 어쩌고 저쩌고 버전관리가 어렵고...... 솔직히 다 개소리다. 

그런 상황을 잘 견디기 위해 S/W 공학이라는 학문이 있는 것이다. 
하지만 그보다 중요한 가치는 고객이다. 
고객을 외면하는 솔루션은 절대 성공하지 못한다. 
고객이 제품과 개발팀을 평가해야지 개발팀이 고객을 평가해서는 안된다.

기능이라는 것은 씨가 뿌려져 조금씩 성장하는 것이지 하루 아침에 
열매가 얻어지는 것은 아니다. 
머리 속으로 안 된다고 판단하지 말고 정말 써보고 적용해보고 개선하는 
과정을 통해 기능은 연마되고 완성도를 가지게 된다. 

우리는 대장장이다. 
칼을 만들지만 최고의 검사도 아니며 전투에 나가지도 않는다. 
하지만 고객을 통해 최고의 칼을 만들 수 있다고 생각한다.
